<!DOCTYPE html>
<html>
<head>
<title>Spinning Sphenocorona (J86) Visualizer</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<style>
  body {
    font-family: 'Inter', sans-serif;
    background-color: #111827; /* Dark gray background */
    color: #e5e7eb; /* Light gray text */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    margin: 0;
    padding: 1rem;
    overflow: hidden; /* Prevent scrollbars from body */
  }
  #visualizationContainer {
    width: 100%;
    max-width: 64rem; /* Limit width on larger screens */
    background-color: #1f2937; /* Slightly lighter dark gray for container */
    padding: 1.5rem;
    border-radius: 0.5rem; /* Rounded corners */
    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Subtle shadow */
  }
  h1 {
    font-size: 1.875rem; /* Tailwind's text-3xl */
    font-weight: 600; /* semibold */
    margin-bottom: 1rem; /* Spacing below title */
    color: #f9fafb; /* Almost white title text */
    text-align: center;
  }
  #canvasContainer {
    width: 100%;
    height: 60vh; /* Responsive height */
    min-height: 400px;
    max-height: 700px;
    border: 1px solid #374151; /* Border color */
    border-radius: 0.375rem; /* Rounded corners for canvas */
    margin-bottom: 1rem;
    position: relative; /* For label renderer positioning */
    background-color: #000000; /* Black background for the canvas itself */
  }
  .controls {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    gap: 0.75rem; /* Spacing between control elements */
    margin-bottom: 0.5rem;
  }
  .controls button {
    background-color: #3b82f6; /* Blue button */
    color: white;
    font-weight: 500; /* medium */
    padding: 0.5rem 1rem;
    border-radius: 0.375rem;
    border: none;
    cursor: pointer;
    transition: background-color 0.2s, opacity 0.2s;
    width: 240px; /* Increased fixed width for all buttons */
    text-align: center; /* Center text within the button */
  }
  .controls button:hover:not(:disabled) {
    background-color: #2563eb; /* Darker blue on hover */
  }
   .controls button:disabled {
    background-color: #4b5563; /* Darker Gray when disabled */
    color: #9ca3af;
    cursor: not-allowed;
  }
  .controls label {
    margin-right: 0.5rem;
    color: #d1d5db; /* Lighter gray for labels */
  }
  .controls input[type="range"] {
    width: 120px;
    cursor: pointer;
  }
  .vertex-label, .dihedral-label {
    color: #ffffff;
    background-color: rgba(0, 0, 0, 0.75);
    padding: 2px 5px;
    border-radius: 3px;
    font-size: 14px; /* A base font-size for scaling */
    font-family: sans-serif;
    pointer-events: none;
    user-select: none;
    position: absolute;
    transform-origin: center center; /* Ensures scaling is from the center */
  }
  .dihedral-label {
    color: #facc15; /* Yellow for dihedral angles */
    font-size: 12px;
  }
</style>
</head>
<body>

<div id="visualizationContainer">
  <h1>Spinning Sphenocorona (J86)</h1>
  <div class="controls">
    <button id="pauseButton" style="width: 120px;">Pause</button>
    <div>
      <label for="speedSlider">Speed:</label>
      <input type="range" id="speedSlider" min="0" max="100" value="20">
    </div>
    <button id="toggleShapeButton">Show Solid</button>
    <button id="toggleLabelsButton">Hide Labels</button>
    <button id="toggleDihedralsButton">Show Dihedrals</button>
    <button id="toggleFaceColorsButton" disabled>Color Faces</button>
    <button id="toggleSquaresSeparationButton">Separate Squares (Indiv.)</button>
    <button id="toggleConnectedSquaresButton">Separate Connected Squares</button>
    <button id="toggleTrianglesSeparationButton">Separate Triangles</button>
    <button id="togglePyramidsSeparationButton">Separate Pyramids</button>
    <button id="toggleAllSeparationButton">Separate All</button>
  </div>
  <div id="canvasContainer">
    </div>
</div>

<script>
// --- Three.js related variables ---
let scene, camera, renderer, modelGroup;
let faceGroups = []; // Will hold a group for each of the 14 faces
let vertexLabels = [];
let dihedralLabels = [];
let raycaster;
let animationId;
let isPaused = false;
let isSolidView = true;
let areLabelsVisible = true;
let areDihedralsVisible = false;
let areFacesColored = false;
let rotationSpeed = 0.005;

// --- State: Separation Modes ---
const SEPARATION_DISTANCE = 1.0;

// Independent Squares Separation
let areIndivSquaresSeparated = false;
let areIndivSquaresSeparatingAnimating = false;
let targetIndivSquaresSeparationState = false;
let indivSquaresSeparationLerpFactor = 0;
let square1SeparationAxis = new THREE.Vector3();
let square2SeparationAxis = new THREE.Vector3();

// Triangles Separation
let areTrianglesSeparated = false;
let areTrianglesSeparatingAnimating = false;
let targetTrianglesSeparationState = false;
let trianglesSeparationLerpFactor = 0;
let triangle1SeparationAxis = new THREE.Vector3();
let triangle2SeparationAxis = new THREE.Vector3();

// Connected Squares Separation
let areConnSquaresSeparated = false;
let areConnSquaresSeparatingAnimating = false;
let targetConnSquaresSeparationState = false;
let connSquaresSeparationLerpFactor = 0;
let connSquaresSeparationAxis = new THREE.Vector3();

// Pyramids Separation
let arePyramidsSeparated = false;
let arePyramidsSeparatingAnimating = false;
let targetPyramidsSeparationState = false;
let pyramidsSeparationLerpFactor = 0;
let pyramidSeparationAxis = new THREE.Vector3();

// All Faces Separation
let areAllSeparated = false;
let isAllSeparatingAnimating = false;
let targetAllSeparationState = false;
let allSeparationLerpFactor = 0;
let faceNormals = []; // To store the normal for each face

// --- Face and Vertex Definitions for Separation ---
let squareFace1, squareFace2, triangleFace1, triangleFace2;
let pyramid1FaceDefs, pyramid2FaceDefs;

// --- Custom Camera Controls ---
let mouseDown = false; let mouseButton = 0;
let mouseX = 0, mouseY = 0;
let cameraDistance = 5; let cameraTheta = 0; let cameraPhi = Math.PI / 4;
let cameraTarget = new THREE.Vector3(0, 0, 0); let cameraPanOffset = new THREE.Vector3(0, 0, 0);
let wasPausedBeforeOrbit = false; let isOrbiting = false;

// --- Data ---
const J86_FACE_COLORS_PALETTE = [ new THREE.Color(0xff6347), new THREE.Color(0x4682b4), new THREE.Color(0x32cd32), new THREE.Color(0xffd700), new THREE.Color(0x9370db), new THREE.Color(0x40e0d0) ];
let assignedFaceColors = [];
let centeredVertexPositions = [];
let J86_FACES_INDICES = []; let J86_FACE_ADJACENCIES = []; let J86_EDGES = [];
let dihedralAngles = [];

// --- J86 Calculation Functions ---
function findK() {
    const f = (x) => 60*x**4 - 48*x**3 - 100*x**2 + 56*x + 23;
    const df = (x) => 240*x**3 - 144*x**2 - 200*x + 56;
    let x = 0.85273; const tolerance = 1e-15; let iterations = 0;
    while (Math.abs(f(x)) > tolerance && iterations < 100) {
        const fx = f(x), dfx = df(x);
        if (Math.abs(dfx) < 1e-10) return NaN;
        x = x - fx / dfx; iterations++;
    }
    return x;
}

function getVerticesJ86(k) {
    if (isNaN(k)) return [];
    const k2 = k * k; if (1 - k2 < 0) return [];
    const term1_z = Math.sqrt(1 - k2);
    const term2_num_inner = 3 - 4 * k2; if (term2_num_inner < 0) return [];
    const term2_den = 2 * Math.sqrt(1 - k2); if (term2_den <= 0) return [];
    const term2_y_add = Math.sqrt(term2_num_inner) / term2_den;
    const term3_z_num = 1 - 2 * k2;
    const term3_z_den = 2 * Math.sqrt(1 - k2); if (term3_z_den <= 0) return [];
    const z_val_for_y = term3_z_num / term3_z_den;
    const term4_z_inner = 0.5 + k - k2; if (term4_z_inner < 0) return [];
    const term4_z = -Math.sqrt(term4_z_inner);
    const y_val = 0.5 + term2_y_add;
    const vertices = [ { id: 0, coords: [0, 0.5, term1_z] }, { id: 1, coords: [0, -0.5, term1_z] }, { id: 2, coords: [k, 0.5, 0] }, { id: 3, coords: [k, -0.5, 0] }, { id: 4, coords: [-k, 0.5, 0] }, { id: 5, coords: [-k, -0.5, 0] }, { id: 6, coords: [0, y_val, z_val_for_y] }, { id: 7, coords: [0, -y_val, z_val_for_y] }, { id: 8, coords: [0.5, 0, term4_z] }, { id: 9, coords: [-0.5, 0, term4_z] } ];
    const centroid = vertices.reduce((acc, v) => [acc[0]+v.coords[0], acc[1]+v.coords[1], acc[2]+v.coords[2]], [0,0,0]);
    centroid.forEach((_,i) => centroid[i] /= vertices.length);
    vertices.forEach(v => v.coords = v.coords.map((c, i) => c - centroid[i]));
    return vertices;
}

function calculateGeometry(vertices) {
    const numVertices = vertices.length; const edgeList = Array.from({ length: numVertices }, () => []); J86_EDGES = [];
    for (let i = 0; i < numVertices; i++) for (let j = i + 1; j < numVertices; j++) {
        const p1 = vertices[i]; const p2 = vertices[j]; const dSq = (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 + (p1[2]-p2[2])**2;
        if (Math.abs(dSq - 1.0) < 1e-4) { edgeList[i].push(j); edgeList[j].push(i); J86_EDGES.push([i, j]); }
    }
    const triangles = [], squares = [];
    for (let i = 0; i < numVertices; i++) for (const j of edgeList[i]) { if (j <= i) continue; for (const k of edgeList[j]) { if (k <= i) continue; if (edgeList[k].includes(i)) triangles.push([i, j, k].sort((a,b)=>a-b)); for (const l of edgeList[k]) { if (l <= i || l === j) continue; if (edgeList[l].includes(i) && !edgeList[i].includes(k) && !edgeList[j].includes(l)) squares.push([i, j, k, l].sort((a,b)=>a-b)); } } }
    const allFoundFaces = [...new Set(triangles.map(t => JSON.stringify(t)))].map(s => JSON.parse(s)).concat([...new Set(squares.map(q => JSON.stringify(q)))].map(s => JSON.parse(s)));
    const centroid = new THREE.Vector3(0,0,0);
    J86_FACES_INDICES = allFoundFaces.map(face => {
        let orderedFace = [...face];
        if (face.length > 3) { let last = face[0]; let remaining = [...face.slice(1)]; orderedFace = [last]; while(remaining.length > 0) { const next = remaining.find(v => edgeList[last].includes(v)); if(!next) break; orderedFace.push(next); last = next; remaining = remaining.filter(v => v !== next); } }
        const p0 = new THREE.Vector3().fromArray(vertices[orderedFace[0]]); const p1 = new THREE.Vector3().fromArray(vertices[orderedFace[1]]); const p2 = new THREE.Vector3().fromArray(vertices[orderedFace[2]]);
        const faceCenter = new THREE.Vector3(); orderedFace.forEach(vIdx => faceCenter.add(new THREE.Vector3().fromArray(vertices[vIdx]))); faceCenter.divideScalar(orderedFace.length);
        const v1 = p1.clone().sub(p0), v2 = p2.clone().sub(p0); const normal = new THREE.Vector3().crossVectors(v1, v2);
        if (normal.dot(faceCenter.clone().sub(centroid)) < 0) return orderedFace.reverse();
        return orderedFace;
    });
    J86_FACE_ADJACENCIES = Array.from({ length: J86_FACES_INDICES.length }, () => []);
    for (let i = 0; i < J86_FACES_INDICES.length; i++) for (let j = i + 1; j < J86_FACES_INDICES.length; j++) {
        if (J86_FACES_INDICES[i].filter(v => J86_FACES_INDICES[j].includes(v)).length >= 2) { J86_FACE_ADJACENCIES[i].push(j); J86_FACE_ADJACENCIES[j].push(i); }
    }
}

function calculateDihedralAngles() {
    dihedralAngles = J86_EDGES.map(edge => {
        const [v1_idx, v2_idx] = edge;
        const sharedFaces = J86_FACES_INDICES.map((face, index) => ({face, index}))
                                             .filter(f => f.face.includes(v1_idx) && f.face.includes(v2_idx));

        if (sharedFaces.length !== 2) return null; // Should not happen in a convex polyhedron

        const face1_indices = sharedFaces[0].face;
        const face2_indices = sharedFaces[1].face;

        const normal1 = calculateFaceNormal(face1_indices, centeredVertexPositions);
        const normal2 = calculateFaceNormal(face2_indices, centeredVertexPositions);

        const angle = Math.acos(normal1.dot(normal2));
        const degrees = 180 - (angle * 180 / Math.PI); // Internal angle

        const p1 = new THREE.Vector3().fromArray(centeredVertexPositions[v1_idx]);
        const p2 = new THREE.Vector3().fromArray(centeredVertexPositions[v2_idx]);
        const midpoint = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);

        return { edge, angle: degrees, midpoint };
    }).filter(d => d !== null);
}


function computeFaceColors() {
    assignedFaceColors = new Array(J86_FACES_INDICES.length).fill(null); let assignedColorIndices = new Array(J86_FACES_INDICES.length).fill(-1);
    for (let i = 0; i < J86_FACES_INDICES.length; i++) {
        let neighborColorIndices = new Set(J86_FACE_ADJACENCIES[i].map(adjIdx => assignedColorIndices[adjIdx]).filter(cIdx => cIdx !== -1));
        for (let c = 0; c < J86_FACE_COLORS_PALETTE.length; c++) if (!neighborColorIndices.has(c)) { assignedColorIndices[i] = c; assignedFaceColors[i] = J86_FACE_COLORS_PALETTE[c]; break; }
        if (assignedFaceColors[i] === null) assignedFaceColors[i] = J86_FACE_COLORS_PALETTE[i % J86_FACE_COLORS_PALETTE.length];
    }
}

// --- Camera Controls ---
function updateCameraPosition() {
    const x = cameraDistance * Math.sin(cameraPhi) * Math.cos(cameraTheta); const y = cameraDistance * Math.cos(cameraPhi); const z = cameraDistance * Math.sin(cameraPhi) * Math.sin(cameraTheta);
    camera.position.set(x, y, z).add(cameraTarget).add(cameraPanOffset); camera.lookAt(cameraTarget.clone().add(cameraPanOffset));
}
function onMouseDown(event) { mouseDown = true; mouseButton = event.button; mouseX = event.clientX; mouseY = event.clientY; event.preventDefault(); if (mouseButton === 0) { isOrbiting = true; wasPausedBeforeOrbit = isPaused; isPaused = true; } }
function onMouseUp(event) { if (isOrbiting && mouseButton === 0) isPaused = wasPausedBeforeOrbit; isOrbiting = false; mouseDown = false; event.preventDefault(); }
function onMouseMove(event) {
    if (!mouseDown) return; const deltaX = event.clientX - mouseX; const deltaY = event.clientY - mouseY;
    if (mouseButton === 0) { cameraTheta -= deltaX * 0.01; cameraPhi += deltaY * 0.01; cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraPhi)); }
    else if (mouseButton === 2) { const panSpeed = 0.002 * cameraDistance; const right = new THREE.Vector3().crossVectors(camera.up, camera.position.clone().sub(cameraTarget).normalize()).normalize(); const up = new THREE.Vector3().crossVectors(camera.position.clone().sub(cameraTarget).normalize(), right).normalize(); cameraPanOffset.add(right.multiplyScalar(-deltaX * panSpeed)); cameraPanOffset.add(up.multiplyScalar(deltaY * panSpeed)); }
    updateCameraPosition(); mouseX = event.clientX; mouseY = event.clientY; event.preventDefault();
}
function onMouseWheel(event) { cameraDistance *= event.deltaY > 0 ? 1.1 : 0.9; cameraDistance = Math.max(1, Math.min(20, cameraDistance)); updateCameraPosition(); event.preventDefault(); }

// --- Main Initialization ---
function performCalculationsAndSetupVisualization() {
    const k_val = findK(); if (isNaN(k_val)) return;
    const verticesObjects = getVerticesJ86(k_val); if (verticesObjects.length === 0) return;
    centeredVertexPositions = verticesObjects.map(v => v.coords);
    calculateGeometry(centeredVertexPositions);
    calculateDihedralAngles();
    computeFaceColors();
    setupThreeJSVisualization();
}

// --- Helper to create mesh groups from geometry data ---
function createMeshGroup(faces, allVertices, faceColors, edges) {
    const solidPos = [], solidColors = [], wfPoints = [];
    faces.forEach(faceData => {
        const { VIds, originalIndex } = faceData;
        const color = faceColors[originalIndex];
        for (let i = 1; i < VIds.length - 1; i++) [VIds[0], VIds[i], VIds[i+1]].forEach(v_idx => {
            solidPos.push(...allVertices[v_idx]); solidColors.push(color.r, color.g, color.b);
        });
    });
    edges.forEach(edge => wfPoints.push(...allVertices[edge[0]], ...allVertices[edge[1]]));

    const group = new THREE.Group();
    if (solidPos.length === 0) return group;

    const solidGeom = new THREE.BufferGeometry(); solidGeom.setAttribute('position', new THREE.Float32BufferAttribute(solidPos, 3)); solidGeom.setAttribute('color', new THREE.Float32BufferAttribute(solidColors, 3)); solidGeom.computeVertexNormals();
    const solidMaterial = new THREE.MeshPhongMaterial({ shininess: 80, specular: 0x222222, flatShading: true, vertexColors: false, color: 0x6082b6, polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 1, side: THREE.DoubleSide });
    const solidMesh = new THREE.Mesh(solidGeom, solidMaterial); solidMesh.name = 'solid';
    const edgesMesh = new THREE.LineSegments(new THREE.EdgesGeometry(solidMesh.geometry, 1), new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1.5 })); edgesMesh.name = 'edges';
    const wfGeom = new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(wfPoints, 3));
    const wfMesh = new THREE.LineSegments(wfGeom, new THREE.LineBasicMaterial({ color: 0x00dd00, linewidth: 2 })); wfMesh.name = 'wireframe';
    group.add(solidMesh, edgesMesh, wfMesh);
    return group;
}

// --- Helper to calculate a face's normal vector ---
function calculateFaceNormal(faceVertices, allVertexPositions) {
    const p0 = new THREE.Vector3().fromArray(allVertexPositions[faceVertices[0]]);
    const p1 = new THREE.Vector3().fromArray(allVertexPositions[faceVertices[1]]);
    const p2 = new THREE.Vector3().fromArray(allVertexPositions[faceVertices[2]]);
    return new THREE.Vector3().crossVectors(p1.clone().sub(p0), p2.clone().sub(p0)).normalize();
}

// --- Helper to compare two faces, ignoring vertex order ---
const compareFaces = (f1, f2) => {
    if (!f1 || !f2 || f1.length !== f2.length) return false;
    const sorted1 = [...f1].sort();
    const sorted2 = [...f2].sort();
    return sorted1.every((val, index) => val === sorted2[index]);
};

// --- Three.js Setup ---
function setupThreeJSVisualization() {
    const canvasContainer = document.getElementById('canvasContainer');
    while (canvasContainer.firstChild) canvasContainer.removeChild(canvasContainer.firstChild);
    if (animationId) cancelAnimationFrame(animationId);

    scene = new THREE.Scene(); raycaster = new THREE.Raycaster();
    camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight); renderer.setPixelRatio(window.devicePixelRatio);
    canvasContainer.appendChild(renderer.domElement);
    renderer.domElement.addEventListener('mousedown', onMouseDown); renderer.domElement.addEventListener('mouseup', onMouseUp); renderer.domElement.addEventListener('mousemove', onMouseMove); renderer.domElement.addEventListener('wheel', onMouseWheel);
    renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
    updateCameraPosition();
    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.2); dirLight.position.set(1.5, 2, 1); scene.add(dirLight);
    
    modelGroup = new THREE.Group(); scene.add(modelGroup);

    // --- Identify all separable faces ---
    const allFoundSquares = J86_FACES_INDICES.filter(f => f.length === 4);
    [squareFace1, squareFace2] = allFoundSquares;
    const t1Verts = [4, 5, 9].sort().toString();
    const t2Verts = [2, 3, 8].sort().toString();
    triangleFace1 = J86_FACES_INDICES.find(f => [...f].sort().toString() === t1Verts);
    triangleFace2 = J86_FACES_INDICES.find(f => [...f].sort().toString() === t2Verts);
    pyramid1FaceDefs = [[1,5,7], [5,9,7], [9,8,7], [8,3,7], [3,1,7]];
    pyramid2FaceDefs = [[0,2,6], [2,8,6], [8,9,6], [9,4,6], [4,0,6]];
    
    // --- Create a group for each of the 14 faces ---
    faceGroups = J86_FACES_INDICES.map((faceVIds, index) => {
        const faceData = [{VIds: faceVIds, originalIndex: index}];
        const faceEdges = J86_EDGES.filter(edge => edge.every(v => faceVIds.includes(v)));
        const group = createMeshGroup(faceData, centeredVertexPositions, assignedFaceColors, faceEdges);
        group.userData.VIds = faceVIds; // Store vertices for later identification
        modelGroup.add(group);
        return group;
    });

    // --- Calculate Separation Axes for all modes ---
    square1SeparationAxis = calculateFaceNormal(squareFace1, centeredVertexPositions);
    square2SeparationAxis = calculateFaceNormal(squareFace2, centeredVertexPositions);
    triangle1SeparationAxis = calculateFaceNormal(triangleFace1, centeredVertexPositions);
    triangle2SeparationAxis = calculateFaceNormal(triangleFace2, centeredVertexPositions);
    
    const p8 = new THREE.Vector3().fromArray(centeredVertexPositions[8]);
    const p9 = new THREE.Vector3().fromArray(centeredVertexPositions[9]);
    const mid1 = new THREE.Vector3().addVectors(p8, p9).multiplyScalar(0.5);
    const p0 = new THREE.Vector3().fromArray(centeredVertexPositions[0]);
    const p1 = new THREE.Vector3().fromArray(centeredVertexPositions[1]);
    const mid2 = new THREE.Vector3().addVectors(p0, p1).multiplyScalar(0.5);
    connSquaresSeparationAxis.subVectors(mid2, mid1).normalize();
    
    const p6 = new THREE.Vector3().fromArray(centeredVertexPositions[6]);
    const p7 = new THREE.Vector3().fromArray(centeredVertexPositions[7]);
    pyramidSeparationAxis.subVectors(p7, p6).normalize();

    // Calculate normals for all faces for the "Separate All" mode
    faceNormals = J86_FACES_INDICES.map(faceVIds => {
        return calculateFaceNormal(faceVIds, centeredVertexPositions);
    });
    
    // Create vertex labels
    vertexLabels = [];
    centeredVertexPositions.forEach((coords, vertexId) => {
        const labelDiv = document.createElement('div'); labelDiv.className = 'vertex-label'; labelDiv.textContent = vertexId;
        labelDiv.style.position = 'absolute'; labelDiv.style.zIndex = '1000'; canvasContainer.appendChild(labelDiv);
        const posVec = new THREE.Vector3().fromArray(coords);
        vertexLabels[vertexId] = { element: labelDiv, position: posVec.clone(), hostFaceGroup: null };
    });

    // Create dihedral labels
    dihedralLabels = [];
    dihedralAngles.forEach((dihedral, index) => {
        const labelDiv = document.createElement('div');
        labelDiv.className = 'dihedral-label';
        labelDiv.textContent = `${dihedral.angle.toFixed(2)}Â°`;
        labelDiv.style.position = 'absolute';
        labelDiv.style.zIndex = '1000';
        canvasContainer.appendChild(labelDiv);
        dihedralLabels[index] = { element: labelDiv, position: dihedral.midpoint.clone() };
    });

    updateShapeAndColorControls();
    rotationSpeed = parseFloat(document.getElementById('speedSlider').value) / 2000;
    animate();
    window.addEventListener('resize', onWindowResize, false);
}

// --- UI and Visibility Update Function ---
function updateShapeAndColorControls() {
    // Toggle solid/wireframe view for all faces
    faceGroups.forEach(group => {
        const solid = group.getObjectByName('solid');
        const edges = group.getObjectByName('edges');
        const wireframe = group.getObjectByName('wireframe');
        if (solid) solid.visible = isSolidView;
        if (edges) edges.visible = isSolidView;
        if (wireframe) wireframe.visible = !isSolidView;
    });
    
    // Update materials for all solid meshes
    faceGroups.forEach(group => {
        const mesh = group.getObjectByName('solid');
        if (!mesh) return;

        mesh.material.vertexColors = areFacesColored;
        let baseColor = 0x6082b6; // Default/core body color
        
        if (!areFacesColored) {
            const VIds = group.userData.VIds;
            if (compareFaces(VIds, squareFace1)) baseColor = 0xff8c00; // Orange
            else if (compareFaces(VIds, squareFace2)) baseColor = 0xde3163; // Cerise
            else if (compareFaces(VIds, triangleFace1)) baseColor = 0x00ced1; // Dark Turquoise
            else if (compareFaces(VIds, triangleFace2)) baseColor = 0x9acd32; // Yellow Green
            else if (pyramid1FaceDefs.some(def => compareFaces(VIds, def))) baseColor = 0xda70d6; // Orchid
            else if (pyramid2FaceDefs.some(def => compareFaces(VIds, def))) baseColor = 0x7b68ee; // Medium Slate Blue
        }
        mesh.material.color.set(areFacesColored ? 0xffffff : baseColor);
        mesh.material.needsUpdate = true;
    });

    // Update button text and state
    document.getElementById('toggleShapeButton').textContent = isSolidView ? 'Show Solid' : 'Show Wireframe';
    document.getElementById('toggleFaceColorsButton').disabled = !isSolidView;
    document.getElementById('toggleFaceColorsButton').textContent = areFacesColored ? 'Monochrome' : 'Color Faces';
    document.getElementById('toggleLabelsButton').textContent = areLabelsVisible ? 'Hide Labels' : 'Show Labels';
    document.getElementById('toggleDihedralsButton').textContent = areDihedralsVisible ? 'Hide Dihedrals' : 'Show Dihedrals';
    
    const indivSqBtn = document.getElementById('toggleSquaresSeparationButton');
    indivSqBtn.textContent = areIndivSquaresSeparatingAnimating ? (targetIndivSquaresSeparationState ? 'Separating...' : 'Joining...') : (areIndivSquaresSeparated ? 'Join Squares (Indiv.)' : 'Separate Squares (Indiv.)');
    
    const connSqBtn = document.getElementById('toggleConnectedSquaresButton');
    connSqBtn.textContent = areConnSquaresSeparatingAnimating ? (targetConnSquaresSeparationState ? 'Separating...' : 'Joining...') : (areConnSquaresSeparated ? 'Join Connected Squares' : 'Separate Connected Squares');
    
    const triBtn = document.getElementById('toggleTrianglesSeparationButton');
    triBtn.textContent = areTrianglesSeparatingAnimating ? (targetTrianglesSeparationState ? 'Separating...' : 'Joining...') : (areTrianglesSeparated ? 'Join Triangles' : 'Separate Triangles');

    const pyrBtn = document.getElementById('togglePyramidsSeparationButton');
    pyrBtn.textContent = arePyramidsSeparatingAnimating ? (targetPyramidsSeparationState ? 'Separating...' : 'Joining...') : (arePyramidsSeparated ? 'Join Pyramids' : 'Separate Pyramids');
    
    const allBtn = document.getElementById('toggleAllSeparationButton');
    allBtn.textContent = isAllSeparatingAnimating ? (targetAllSeparationState ? 'Separating...' : 'Joining...') : (areAllSeparated ? 'Join All' : 'Separate All');
}

// --- Window Resize & Screen Position ---
function onWindowResize() { if (!camera || !renderer) return; const c = document.getElementById('canvasContainer'); camera.aspect = c.clientWidth / c.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(c.clientWidth, c.clientHeight); }
function toScreenPosition(position, camera, renderer) { const vector = position.clone().project(camera); return { x: (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth, y: (vector.y * -0.5 + 0.5) * renderer.domElement.clientHeight, z: vector.z }; }

// --- Animation Loop ---
function animate() {
    animationId = requestAnimationFrame(animate);
    if (!isPaused && modelGroup) {
        modelGroup.rotation.y += rotationSpeed;
        modelGroup.rotation.x += rotationSpeed * 0.5;
    }

    // --- Handle all animations simultaneously ---
    let currentSeparationSpeed;
    if (isOrbiting) {
        currentSeparationSpeed = 0.03; 
    } else {
        currentSeparationSpeed = (rotationSpeed * 1.5) + 0.01;
    }

    if (areIndivSquaresSeparatingAnimating) {
        indivSquaresSeparationLerpFactor += targetIndivSquaresSeparationState ? currentSeparationSpeed : -currentSeparationSpeed;
        indivSquaresSeparationLerpFactor = Math.max(0, Math.min(1, indivSquaresSeparationLerpFactor));
        if ((targetIndivSquaresSeparationState && indivSquaresSeparationLerpFactor === 1) || (!targetIndivSquaresSeparationState && indivSquaresSeparationLerpFactor === 0)) {
            areIndivSquaresSeparatingAnimating = false; areIndivSquaresSeparated = targetIndivSquaresSeparationState; updateShapeAndColorControls();
        }
    }
    
    if (areTrianglesSeparatingAnimating) {
        trianglesSeparationLerpFactor += targetTrianglesSeparationState ? currentSeparationSpeed : -currentSeparationSpeed;
        trianglesSeparationLerpFactor = Math.max(0, Math.min(1, trianglesSeparationLerpFactor));
        if ((targetTrianglesSeparationState && trianglesSeparationLerpFactor === 1) || (!targetTrianglesSeparationState && trianglesSeparationLerpFactor === 0)) {
            areTrianglesSeparatingAnimating = false; areTrianglesSeparated = targetTrianglesSeparationState; updateShapeAndColorControls();
        }
    }

    if (areConnSquaresSeparatingAnimating) {
        connSquaresSeparationLerpFactor += targetConnSquaresSeparationState ? currentSeparationSpeed : -currentSeparationSpeed;
        connSquaresSeparationLerpFactor = Math.max(0, Math.min(1, connSquaresSeparationLerpFactor));
        if ((targetConnSquaresSeparationState && connSquaresSeparationLerpFactor === 1) || (!targetConnSquaresSeparationState && connSquaresSeparationLerpFactor === 0)) {
            areConnSquaresSeparatingAnimating = false; areConnSquaresSeparated = targetConnSquaresSeparationState; updateShapeAndColorControls();
        }
    }

    if (arePyramidsSeparatingAnimating) {
        pyramidsSeparationLerpFactor += targetPyramidsSeparationState ? currentSeparationSpeed : -currentSeparationSpeed;
        pyramidsSeparationLerpFactor = Math.max(0, Math.min(1, pyramidsSeparationLerpFactor));
        if ((targetPyramidsSeparationState && pyramidsSeparationLerpFactor === 1) || (!targetPyramidsSeparationState && pyramidsSeparationLerpFactor === 0)) {
            arePyramidsSeparatingAnimating = false; arePyramidsSeparated = targetPyramidsSeparationState; updateShapeAndColorControls();
        }
    }
    
    if (isAllSeparatingAnimating) {
        allSeparationLerpFactor += targetAllSeparationState ? currentSeparationSpeed : -currentSeparationSpeed;
        allSeparationLerpFactor = Math.max(0, Math.min(1, allSeparationLerpFactor));
        if ((targetAllSeparationState && allSeparationLerpFactor === 1) || (!targetAllSeparationState && allSeparationLerpFactor === 0)) {
            isAllSeparatingAnimating = false;
            areAllSeparated = targetAllSeparationState;
            updateShapeAndColorControls();
        }
    }

    // --- Apply cumulative transformations to each face ---
    const c_ind_sq = indivSquaresSeparationLerpFactor * SEPARATION_DISTANCE;
    const c_con_sq = connSquaresSeparationLerpFactor * SEPARATION_DISTANCE;
    const c_tri = trianglesSeparationLerpFactor * SEPARATION_DISTANCE;
    const c_pyr = pyramidsSeparationLerpFactor * SEPARATION_DISTANCE;
    const c_all = allSeparationLerpFactor * SEPARATION_DISTANCE;

    faceGroups.forEach((group, index) => {
        const VIds = group.userData.VIds;
        group.position.set(0,0,0); // Reset position each frame

        // Individual Squares
        if (compareFaces(VIds, squareFace1)) group.position.add(square1SeparationAxis.clone().multiplyScalar(c_ind_sq));
        if (compareFaces(VIds, squareFace2)) group.position.add(square2SeparationAxis.clone().multiplyScalar(c_ind_sq));
        
        // Connected Squares
        if (compareFaces(VIds, squareFace1) || compareFaces(VIds, squareFace2)) {
            group.position.add(connSquaresSeparationAxis.clone().multiplyScalar(c_con_sq));
        }

        // Triangles
        if (compareFaces(VIds, triangleFace1)) group.position.add(triangle1SeparationAxis.clone().multiplyScalar(c_tri));
        if (compareFaces(VIds, triangleFace2)) group.position.add(triangle2SeparationAxis.clone().multiplyScalar(c_tri));

        // Pyramids
        if (pyramid1FaceDefs.some(def => compareFaces(VIds, def))) group.position.add(pyramidSeparationAxis.clone().multiplyScalar(c_pyr));
        if (pyramid2FaceDefs.some(def => compareFaces(VIds, def))) group.position.add(pyramidSeparationAxis.clone().multiplyScalar(-c_pyr));

        // All face separation
        const normal = faceNormals[index];
        if (normal) {
            group.position.add(normal.clone().multiplyScalar(c_all));
        }
    });

    modelGroup.updateMatrixWorld(true);
    const camWorldPos = new THREE.Vector3(); camera.getWorldPosition(camWorldPos);

    // --- Update Vertex Labels and Occlusion ---
    vertexLabels.forEach((labelObj, vertexId) => {
        // Find the best host face for the label on every frame
        let bestHost = faceGroups.find(g => {
            const VIds = g.userData.VIds;
            if ((areAllSeparated || isAllSeparatingAnimating)) return g.userData.VIds.includes(vertexId);
            if ((arePyramidsSeparated || arePyramidsSeparatingAnimating) && (pyramid1FaceDefs.some(def => compareFaces(VIds, def)) || pyramid2FaceDefs.some(def => compareFaces(VIds, def)))) return g.userData.VIds.includes(vertexId);
            if ((areConnSquaresSeparated || areConnSquaresSeparatingAnimating) && (compareFaces(VIds, squareFace1) || compareFaces(VIds, squareFace2))) return g.userData.VIds.includes(vertexId);
            if ((areIndivSquaresSeparated || areIndivSquaresSeparatingAnimating) && (compareFaces(VIds, squareFace1) || compareFaces(VIds, squareFace2))) return g.userData.VIds.includes(vertexId);
            if ((areTrianglesSeparated || areTrianglesSeparatingAnimating) && (compareFaces(VIds, triangleFace1) || compareFaces(VIds, triangleFace2))) return g.userData.VIds.includes(vertexId);
            return false;
        });

        if (!bestHost) {
            bestHost = faceGroups.find(g => g.userData.VIds.includes(vertexId));
        }
        labelObj.hostFaceGroup = bestHost;

        if (labelObj.hostFaceGroup) {
            const finalVertexWorldPosition = labelObj.position.clone().applyMatrix4(labelObj.hostFaceGroup.matrixWorld);
            const distToVertex = finalVertexWorldPosition.distanceTo(camWorldPos);
            
            const referenceDistance = 5; 
            const minScale = 0.4;
            const maxScale = 1.2; 
            let scale = referenceDistance / distToVertex;
            scale = Math.max(minScale, Math.min(maxScale, scale));
            
            let showLabel = areLabelsVisible;
            if (showLabel && isSolidView) {
                if (distToVertex > 1e-5) {
                    raycaster.set(camWorldPos, finalVertexWorldPosition.clone().sub(camWorldPos).normalize());
                    const occluderMeshes = faceGroups.map(g => g.getObjectByName('solid')).filter(m => m);
                    const intersects = raycaster.intersectObjects(occluderMeshes, false);
                    if (intersects.length > 0 && intersects[0].distance < distToVertex - 0.05) {
                        showLabel = false;
                    }
                }
            }

            labelObj.element.style.display = 'none';
            if (showLabel) {
                const screenPos = toScreenPosition(finalVertexWorldPosition, camera, renderer);
                if (screenPos.z < 1) {
                    labelObj.element.style.display = 'block';
                    labelObj.element.style.left = `${screenPos.x}px`;
                    labelObj.element.style.top = `${screenPos.y}px`;
                    labelObj.element.style.transform = `translate(-50%, -50%) scale(${scale})`;
                }
            }
        }
    });
    
    // --- Update Dihedral Labels ---
    dihedralLabels.forEach((labelObj, index) => {
        const dihedral = dihedralAngles[index];
        const [v1_idx, v2_idx] = dihedral.edge;

        // Determine which face groups this edge belongs to
        const hostGroups = faceGroups.filter(g => g.userData.VIds.includes(v1_idx) && g.userData.VIds.includes(v2_idx));
        
        let finalMidpoint;
        if (hostGroups.length > 0) {
            // Average the transformed midpoint from each host group
            finalMidpoint = new THREE.Vector3();
            hostGroups.forEach(host => {
                finalMidpoint.add(labelObj.position.clone().applyMatrix4(host.matrixWorld));
            });
            finalMidpoint.divideScalar(hostGroups.length);
        } else {
            // Fallback for wireframe or other cases
            finalMidpoint = labelObj.position.clone().applyMatrix4(modelGroup.matrixWorld);
        }
        
        const distToMidpoint = finalMidpoint.distanceTo(camWorldPos);
        const referenceDistance = 5;
        const scale = Math.max(0.4, Math.min(1.2, referenceDistance / distToMidpoint));

        let showLabel = areDihedralsVisible;
        if (showLabel && isSolidView) {
             if (distToMidpoint > 1e-5) {
                raycaster.set(camWorldPos, finalMidpoint.clone().sub(camWorldPos).normalize());
                const occluderMeshes = faceGroups.map(g => g.getObjectByName('solid')).filter(m => m);
                const intersects = raycaster.intersectObjects(occluderMeshes, false);
                if (intersects.length > 0 && intersects[0].distance < distToMidpoint - 0.1) {
                    showLabel = false;
                }
            }
        }

        labelObj.element.style.display = 'none';
        if (showLabel) {
            // Offset label "underneath" the edge from the camera's perspective
            const screenPos = toScreenPosition(finalMidpoint, camera, renderer);
            if (screenPos.z < 1) {
                 labelObj.element.style.display = 'block';
                 labelObj.element.style.left = `${screenPos.x}px`;
                 labelObj.element.style.top = `${screenPos.y + 15 * scale}px`; // Offset down
                 labelObj.element.style.transform = `translate(-50%, -50%) scale(${scale})`;
            }
        }
    });


    renderer.render(scene, camera);
}

// --- Event Listeners ---
document.getElementById('pauseButton').addEventListener('click', () => { if (isOrbiting) wasPausedBeforeOrbit = !isPaused; isPaused = !isPaused; document.getElementById('pauseButton').textContent = isPaused ? 'Resume' : 'Pause'; });
document.getElementById('speedSlider').addEventListener('input', (e) => { rotationSpeed = parseFloat(e.target.value) / 2000; });
document.getElementById('toggleShapeButton').addEventListener('click', () => { isSolidView = !isSolidView; updateShapeAndColorControls(); });
document.getElementById('toggleLabelsButton').addEventListener('click', () => { areLabelsVisible = !areLabelsVisible; updateShapeAndColorControls(); });
document.getElementById('toggleDihedralsButton').addEventListener('click', () => { areDihedralsVisible = !areDihedralsVisible; updateShapeAndColorControls(); });
document.getElementById('toggleFaceColorsButton').addEventListener('click', () => { if(isSolidView) { areFacesColored = !areFacesColored; updateShapeAndColorControls(); } });
document.getElementById('toggleSquaresSeparationButton').addEventListener('click', () => {
    if (!areIndivSquaresSeparatingAnimating) {
        targetIndivSquaresSeparationState = !areIndivSquaresSeparated;
        areIndivSquaresSeparatingAnimating = true;
        updateShapeAndColorControls();
    }
});
document.getElementById('toggleTrianglesSeparationButton').addEventListener('click', () => {
    if (!areTrianglesSeparatingAnimating) {
        targetTrianglesSeparationState = !areTrianglesSeparated;
        areTrianglesSeparatingAnimating = true;
        updateShapeAndColorControls();
    }
});
document.getElementById('toggleConnectedSquaresButton').addEventListener('click', () => {
    if (!areConnSquaresSeparatingAnimating) {
        targetConnSquaresSeparationState = !areConnSquaresSeparated;
        areConnSquaresSeparatingAnimating = true;
        updateShapeAndColorControls();
    }
});
document.getElementById('togglePyramidsSeparationButton').addEventListener('click', () => {
    if (!arePyramidsSeparatingAnimating) {
        targetPyramidsSeparationState = !arePyramidsSeparated;
        arePyramidsSeparatingAnimating = true;
        updateShapeAndColorControls();
    }
});
document.getElementById('toggleAllSeparationButton').addEventListener('click', () => {
    if (!isAllSeparatingAnimating) {
        targetAllSeparationState = !areAllSeparated;
        isAllSeparatingAnimating = true;
        updateShapeAndColorControls();
    }
});


// --- Load and Unload ---
window.onload = performCalculationsAndSetupVisualization;
window.addEventListener('beforeunload', () => {
    if (animationId) cancelAnimationFrame(animationId); if (renderer) renderer.dispose();
    if (scene) scene.traverse(o => { if(o.geometry) o.geometry.dispose(); if(o.material) (Array.isArray(o.material)?o.material:[o.material]).forEach(m => m.dispose()); });
    const canvasContainer = document.getElementById('canvasContainer');
    if (canvasContainer) {
        canvasContainer.querySelectorAll('.vertex-label').forEach(label => label.remove());
        canvasContainer.querySelectorAll('.dihedral-label').forEach(label => label.remove());
    }
    window.removeEventListener('resize', onWindowResize);
});
</script>
</body>
</html>
